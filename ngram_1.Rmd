---
title: "N-Gram Intrusion Detection (Part 1)"
author: "Kexuan Zou"
date: "April 19, 2018; revision: Jun 8, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[Go to Part 2](https://klauschow.me/research/ngram_2.html)

## Introduction
SDMC2010 API sequence corpus contains a subset of the Windows APU/System-Calls which can be used for differentiating a malware from a benign software by analyzing the API / system call traces. The data is separated by "," into two columns: the first column designates if a software is a malware (0 for benign software and 1 for malware); the second column contains a list of system call traces of that software at runtime. First separate malwares from benign softwares:

```{r}
data <- read.csv("CSDMC_API_Train.csv", header=FALSE, sep=",", stringsAsFactors=FALSE)
malicious <- subset(data, V1==1)
benign <- subset(data, V1==0)
cat("Number of malwares in the training set is", length(malicious$V1), "\n")
cat("Number of benign softwares in the training set is", length(benign$V1), "\n")
```

For example, we can view part of the system call trace of a particular sample:
```{r}
substr(malicious$V2[1], 1, 100)
```

## N-Gram with White / Black Listing
Since it is impractical to enumerate all possible sequences of system calls triggering a potential harmful operation, we can use **N-Gram** algorithm. N-Gram defines a normal behavior for a process by using sequence of system calls. System call trace of length N is recorded during program execution and the sequence is searched in the database. If the sequence is in the database then syscall is valid; otherwise, it is an intrusion or an unseen sequence. We can further improve the algorithm by using N-Gram algorithm in conjunction with a computer security technique called **White / black listing**. We can create a database that maintains hashes for operating system and popular applications in its white list, and known infected files in its black list. This requires us to apply the N-Gram algorithm in both training sets of benign softwares and malwares, and then retrieve the *k* most frequent ngrams from both lists:

```{r}
library(ngram)
n_sequence <- 3
ng_mal <- ngram(malicious$V2, n=n_sequence)
ng_ben <- ngram(benign$V2, n=n_sequence)
```

In this example, I set $k=90$ and $l=45$ to get the most frequent 90 3-grams from malware dataset, and the most frequent 45 3-grams from benign software dataset. Then I put all benign sequences into a white list and remove them from the malware's black list.

```{r}
k <- 90
l <- 45
list_mal <- head(get.phrasetable(ng_mal), k)
list_ben <- head(get.phrasetable(ng_ben), l)
for (i in 1:l) {
  query_idx = match(list_ben$ngrams[i], list_mal$ngrams)
  if (!is.na(query_idx)) { # match is found, delete from list_mal as a false positive
    list_mal <- list_mal[-query_idx,]
  }
}
```

## Sequence Match
Given a software $x_i\in \textbf{X}$ and its corresponding system call trace $s_i$, we want to know if it is classified as a malware. Based on the `list_mal` generated above, an array representing whether each word sequence in `list_mal` exists in $s_i$. I define it as a **primary sequence** of $s_i$.

```{r}
count = function(haystack, needle) {
  return(length(grep(haystack, needle)))
}

prim_mal_1 <- c()
prim_ben_1 <- c()

for (i in 1:nrow(list_mal)) {
  prim_mal_1[i] <- count(list_mal$ngrams[i], malicious$V2[1])
  prim_ben_1[i] <- count(list_mal$ngrams[i], benign$V2[1])
}

cat("Primary sequence for a malware: ", prim_mal_1, "\n")
cat("Primary sequence for a benign software: ", prim_ben_1, "\n")
```

Append corresponding label for each primary sequence match and write to a `prim.csv` file; we will use this file in later sections.

```{r}
prim_i <- c()

# if file exists delete it first
if (file.exists("prim.csv"))
  file.remove("prim.csv")

# for each malware, generate primary sequence
for (item in malicious$V2) {
  for (i in 1:nrow(list_mal)) {
    prim_i[i] <- count(list_mal$ngrams[i], item)
  }
  prim_i[i+1] <- 1 # append label
  line <- as.matrix(t(prim_i))
  write.table(line, file = "prim.csv", sep = ",", col.names = FALSE, row.names = FALSE, append=TRUE)
}

# for each benign software, generate primary sequence
for (item in benign$V2) {
  for (i in 1:nrow(list_mal)) {
    prim_i[i] <- count(list_mal$ngrams[i], item)
  }
  prim_i[i+1] <- 0 # append label
  line <- as.matrix(t(prim_i))
  write.table(line, file = "prim.csv", sep = ",", col.names = FALSE, row.names = FALSE, append=TRUE)
}
```

[Go to Part 2](https://klauschow.me/research/ngram_2.html)
